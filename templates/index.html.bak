<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ePaper Web UI</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { border: 1px solid #aaa; display: block; margin-top: 10px; }
    .form-group { margin-bottom: 1em; }
    .slider-reset { margin-left: 1em; }
  </style>
</head>
<body>
  <h1>ePaper Display Web UI</h1>

  <div class="form-group">
    <label for="image">Upload Image:</label>
    <input type="file" id="image" accept="image/*">
  </div>

  <div class="form-group">
    <label for="browse_images">Or Select Previous:</label>
    <select id="browse_images"></select>
  </div>

  <div class="form-group" id="slider-group">
    <label>Contrast:</label>
    <input type="range" id="contrast" min="0.0" max="3.0" value="1.0" step="0.1">
    <label>Brightness:</label>
    <input type="range" id="brightness" min="0.0" max="2.0" value="1.0" step="0.1">
    <label>Saturation:</label>
    <input type="range" id="saturation" min="0.0" max="2.0" value="1.0" step="0.1">
    <label>Sharpness:</label>
    <input type="range" id="sharpness" min="0.0" max="5.0" value="1.0" step="0.1">
    <label>Green Bias:</label>
    <!-- inverted logic: higher = STRONGER green force -->
    <input type="range" id="green_bias" min="0.0" max="2.0" value="0.0" step="0.05">
    <button type="button" id="reset_sliders" class="slider-reset">Reset</button>
  </div>

  <div class="form-group">
    <label>Resize Mode:</label>
    <label><input type="radio" name="resizemode" value="pad" checked> Pad</label>
    <label><input type="radio" name="resizemode" value="crop"> Crop</label>
  </div>

  <div class="form-group">
    <label><input type="checkbox" id="show_overlay"> Show Overlay Text</label><br>
    <input type="text" id="overlay_text" placeholder="Enter overlay text">
    <select id="overlay_position">
      <option value="top-left">Top Left</option>
      <option value="top-right">Top Right</option>
      <option value="bottom-left">Bottom Left</option>
      <option value="bottom-right">Bottom Right</option>
    </select>
    <input type="number" id="overlay_font_size" value="18">
    <input type="color" id="overlay_font_color" value="#000000">
  </div>

  <div class="form-group">
    <button id="send">Send to Display</button>
  </div>

  <hr>
  <h2>Generate Image with Prompt</h2>
  <form id="generate-form">
    <input type="text" id="prompt" placeholder="Enter a prompt...">
    <button type="submit">Generate</button>
  </form>

  <canvas id="preview" width="800" height="480"></canvas>

  <script>
    // === Global Elements & Helpers ===
    let currentImage = null;
    const canvas  = document.getElementById('preview');
    const ctx     = canvas.getContext('2d');

    const DEFAULTS = {
      contrast:   1.0,
      brightness: 1.0,
      saturation: 1.0,
      sharpness:  1.0,
      green_bias: 0.0
    };

    const clamp = v => Math.max(0, Math.min(255, v));

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16)} : null;
    }

    // === Ensure sliders & preview start at defaults ===
    window.addEventListener('DOMContentLoaded', () => {
      Object.entries(DEFAULTS).forEach(([id,val]) => {
        document.getElementById(id).value = val;
      });
      updatePreview();           // <-- draw once with defaults
    });

    // === Core Preview Function ===
    const updatePreview = () => {
      if (!currentImage) return; // nothing to show yet

      const contrast   = parseFloat(document.getElementById('contrast').value);
      const brightness = parseFloat(document.getElementById('brightness').value);
      const saturation = parseFloat(document.getElementById('saturation').value);
      const sharpness  = parseFloat(document.getElementById('sharpness').value); // placeholder for backend use
      const greenBias  = parseFloat(document.getElementById('green_bias').value);
      const resizeMode = document.querySelector('input[name="resizemode"]:checked').value;

      // --- Resize (pad or crop) onto temp canvas ---
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      const tctx = tmp.getContext('2d');
      const iw = currentImage.width, ih = currentImage.height;
      const cw = tmp.width, ch = tmp.height;
      const scale = (resizeMode === 'pad') ? Math.min(cw/iw, ch/ih) : Math.max(cw/iw, ch/ih);
      const sw = iw * scale, sh = ih * scale;
      const dx = (cw - sw) / 2, dy = (ch - sh) / 2;
      tctx.drawImage(currentImage, dx, dy, sw, sh);

      // --- Pixel-level adjustments ---
      const imgData = tctx.getImageData(0,0,cw,ch); const data = imgData.data;
      for (let i=0;i<data.length;i+=4) {
        let r = data[i], g = data[i+1], b = data[i+2];

        // contrast then brightness
        r = ((r-128)*contrast + 128) * brightness;
        g = ((g-128)*contrast + 128) * brightness;
        b = ((b-128)*contrast + 128) * brightness;

        // inverted green bias: bigger slider = STRONGER bias
        if (g > r / greenBias && g > b / greenBias) {
          r = 0; g = 255; b = 0;
        }

        // saturation
        const avg = (r+g+b)/3;
        r = avg + (r-avg)*saturation;
        g = avg + (g-avg)*saturation;
        b = avg + (b-avg)*saturation;

        data[i]   = clamp(r);
        data[i+1] = clamp(g);
        data[i+2] = clamp(b);
      }
      tctx.putImageData(imgData,0,0);

      // --- Optional overlay text ---
      if (document.getElementById('show_overlay').checked) {
        const text = document.getElementById('overlay_text').value;
        const pos  = document.getElementById('overlay_position').value;
        const fs   = parseInt(document.getElementById('overlay_font_size').value);
        const rgb  = hexToRgb(document.getElementById('overlay_font_color').value);
        tctx.font = `${fs}px sans-serif`;
        tctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
        tctx.textBaseline = 'top';
        const txtW = tctx.measureText(text).width;
        let x = 10, y = 10;
        if (pos.includes('right'))  x = cw - txtW - 10;
        if (pos.includes('bottom')) y = ch - fs - 10;
        tctx.shadowColor = 'rgba(0,0,0,0.3)';
        tctx.shadowOffsetX = 1; tctx.shadowOffsetY = 1; tctx.shadowBlur = 1;
        tctx.fillText(text,x,y);
      }

      ctx.clearRect(0,0,cw,ch);
      ctx.drawImage(tmp,0,0);
    };

    // === Event wiring ===
    const sliderIds = ['contrast','brightness','saturation','sharpness','green_bias'];
    [...sliderIds,'overlay_text','overlay_position','overlay_font_size','overlay_font_color','show_overlay']
      .forEach(id => document.getElementById(id).addEventListener('input', updatePreview));

    document.querySelectorAll('input[name="resizemode"]').forEach(r => r.addEventListener('change', updatePreview));

    document.getElementById('reset_sliders').addEventListener('click', () => {
      Object.entries(DEFAULTS).forEach(([id,val]) => {
        document.getElementById(id).value = val;
      });
      updatePreview();
    });

    // --- Image file upload ---
    document.getElementById('image').addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const img = new Image();
        img.onload = () => { currentImage = img; updatePreview(); };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(f);
    });

    // --- Populate dropdown with uploaded images ---
    async function loadFileList() {
      const res = await fetch('/list_uploads');
      const files = await res.json();
      const sel = document.getElementById('browse_images');
      sel.innerHTML = files.map(f => `<option value="${f}">${f}</option>`).join('');
      if (files.length) loadSelectedImage(files[0]);
    }

    function loadSelectedImage(fname) {
      const img = new Image();
      img.onload = () => { currentImage = img; updatePreview(); };
      img.src = `/uploads/${fname}`;
    }
    document.getElementById('browse_images').addEventListener('change', e => loadSelectedImage(e.target.value));
    loadFileList();

    // --- Generate via backend ---
    document.getElementById('generate-form').addEventListener('submit', async e => {
      e.preventDefault();
      const prompt = document.getElementById('prompt').value;
      const fd = new FormData(); fd.append('prompt',prompt);
      const res = await fetch('/generate',{method:'POST',body:fd});
      const data = await res.json();
      if (data.filename) {
        loadSelectedImage(data.filename);
      }
    });

    // --- Send to display ---
    document.getElementById('send').addEventListener('click', () => {
      if (!currentImage) return alert('No image to send.');
      canvas.toBlob(async blob => {
        const fd = new FormData();
        fd.append('image',blob,'processed.png');
        // basic params (backend currently only uses some)
        fd.append('contrast',document.getElementById('contrast').value);
        fd.append('sharpness',document.getElementById('sharpness').value);
        fd.append('green_bias',document.getElementById('green_bias').value);
        fd.append('resizemode',document.querySelector('input[name="resizemode"]:checked').value);
        // overlay (backend draws it) if checkbox unchecked
        if (!document.getElementById('show_overlay').checked) {
          fd.append('show_overlay','on');
          fd.append('overlay_text',document.getElementById('overlay_text').value);
          fd.append('overlay_position',document.getElementById('overlay_position').value);
          fd.append('overlay_font_size',document.getElementById('overlay_font_size').value);
          fd.append('overlay_font_color',document.getElementById('overlay_font_color').value);
        }
        await fetch('/',{method:'POST',body:fd});
        alert('Image sent to display!');
      });
    });
  </script>
</body>
</html>
